#!{{BASH_BIN}}

{{BASH_RLOCATION_FN}}

runfiles_export_envvars

set -o errexit -o nounset -o pipefail

PWD=$(pwd)

function alocation {
  local P=$1
  if [[ "${P:0:1}" == "/" ]]; then
    echo "${P}"
  else
    echo "${PWD}/${P}"
  fi
}

export BAZEL_WORKSPACE_NAME="{{BAZEL_WORKSPACE_NAME}}"

function wheel_location {
  local P=$1
  if [[ "${P:0:3}" == "../" ]]; then
    echo $(rlocation "${P:3}")
  else
    echo $(rlocation "${BAZEL_WORKSPACE_NAME}/${P}")
  fi
}

export -f wheel_location

# Resolved from the py_interpreter via PyInterpreterInfo.
PYTHON_LOCATION="$(rlocation {{PYTHON_INTERPRETER_PATH}})"
PYTHON="${PYTHON_LOCATION} {{INTERPRETER_FLAGS}}"
PYTHON_BIN_DIR=$(dirname "${PYTHON}")
PIP_LOCATION="${PYTHON_BIN_DIR}/pip"
PYTHON_SITE_PACKAGES=$(${PYTHON} -c 'import site; print(site.getsitepackages()[0])')
PTH_FILE="$(alocation "$(rlocation {{PTH_FILE}})")"
PIP_FIND_LINKS_SH=$(rlocation {{PIP_FIND_LINKS_SH}})
PIP_FIND_LINKS=$("${PIP_FIND_LINKS_SH}" | tr '\n' ' ')
ENTRYPOINT="$(rlocation {{BINARY_ENTRY_POINT}})"

# Convenience vars for the Python virtual env that's created.
RUNFILES_VENV_LOCATION=$(alocation "${RUNFILES_DIR}/{{VENV_NAME}}")
VENV_LOCATION="{{VENV_LOCATION}}"
VBIN_LOCATION="${VENV_LOCATION}/bin"
VPIP_LOCATION="${VBIN_LOCATION}/pip"
VPYTHON="${VBIN_LOCATION}/python3 {{INTERPRETER_FLAGS}}"
VPIP="${VPYTHON} -m pip"

# Create a virtual env to run inside. This allows us to not have to manipulate the PYTHON_PATH to find external
# dependencies.
# We can also now specify the `-I` (isolated) flag to Python, stopping Python from adding the script path to sys.path[0]
# which we have no control over otherwise.
# This does however have some side effects as now all other PYTHON* env vars are ignored.

# The venv is intentionally created without pip, as when the venv is created with pip, `ensurepip` is used which will
# use the bundled version of pip, which does not match the version of pip bundled with the interpreter distro.
# So we symlink in this ourselves.
VENV_FLAGS=(
  "--without-pip"
  "--clear"
)
${PYTHON} -m venv "${VENV_LOCATION}" "${VENV_FLAGS[@]}"

# Activate the venv, disable changing the prompt
export VIRTUAL_ENV_DISABLE_PROMPT=1
. "${VBIN_LOCATION}/activate"
unset VIRTUAL_ENV_DISABLE_PROMPT

# Now symlink in pip from the toolchain
# Also link to `pip` as well as `pip3`. Python venv will also link `pip3.x`, but this seems unnecessary for this use
ln -snf "${PIP_LOCATION}" "${VPIP_LOCATION}"
ln -snf "${VPIP_LOCATION}" "${VBIN_LOCATION}/pip3"

# Need to symlink in the pip site-packages folder not just the binary.
# Ask Python where the site-packages folder is and symlink the pip package in from the toolchain
VENV_SITE_PACKAGES=$(${VPYTHON} -c 'import site; print(site.getsitepackages()[0])')
ln -snf "${PYTHON_SITE_PACKAGES}/pip" "${VENV_SITE_PACKAGES}/pip"
ln -snf "${PYTHON_SITE_PACKAGES}/_distutils_hack" "${VENV_SITE_PACKAGES}/_distutils_hack"
ln -snf "${PYTHON_SITE_PACKAGES}/setuptools" "${VENV_SITE_PACKAGES}/setuptools"

INSTALL_WHEELS={{INSTALL_WHEELS}}
if [ "$INSTALL_WHEELS" = true ]; then
  # Call to pip to "install" our dependencies. The `find-links` section in the config points to the external downloaded wheels,
  # while `--no-index` ensures we don't reach out to PyPi
  # We may hit command line length limits if passing a large number of find-links flags, so set them on the PIP_FIND_LINKS env var
  export PIP_FIND_LINKS

  # TODO: This can likely be generated by an action up front, but this is fine for now
  read -r -a WHEELS <<< "${PIP_FIND_LINKS}"
  REQUIREMENTS_FILE="$(mktemp)"
  printf "%s\n" "${WHEELS[@]}" > "${REQUIREMENTS_FILE}"

  PIP_FLAGS=(
    "--quiet"
    "--no-compile"
    "--require-virtualenv"
    "--no-input"
    "--no-cache-dir"
    "--disable-pip-version-check"
    "--no-python-version-warning"
    "--only-binary=:all:"
    "--no-dependencies"
    "--no-index"
  )

  ${VPIP} install "${PIP_FLAGS[@]}" -r "${REQUIREMENTS_FILE}"
  rm "${REQUIREMENTS_FILE}"

  unset PIP_FIND_LINKS
fi

# Create the site-packages pth file containing all our first party dependency paths. These are from all direct and transitive
# py_library rules.
# The .pth file adds to the interpreters sys.path, without having to set `PYTHONPATH`. This allows us to still
# run with the interpreter with the `-I` flag. This stops some import mechanisms breaking out the sandbox by using
# relative imports.
# This is cat'd in so we don't have to have more fun with runfiles symlink paths.
cat "${PTH_FILE}" > "${VENV_SITE_PACKAGES}/first_party.pth"

# Set all the env vars here, just before we launch
{{PYTHON_ENV}}

# We can stop here an not run the py_binary / py_test entrypoint and just create the venv.
# This can be useful for editor support.
RUN_BINARY_ENTRY_POINT={{RUN_BINARY_ENTRY_POINT}}
if [ "$RUN_BINARY_ENTRY_POINT" = true ]; then
  # Finally, launch the entrypoint
  ${VPYTHON} "${ENTRYPOINT}" -- "$@"
fi

# Deactivate the venv
deactivate

# Unset any set env vars
{{PYTHON_ENV_UNSET}}
unset BAZEL_WORKSPACE_NAME
